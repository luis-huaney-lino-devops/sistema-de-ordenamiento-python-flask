{% extends "base.html" %} {% block title %}Menu principal{% endblock %} {% block
    header %}{{ super() }}{% endblock %} {% block content %}
    
    <head>
      <link
        rel="stylesheet"
        type="text/css"
        href="{{ url_for('static', filename='css/forms.css') }}"
      />
    </head>
    <style>
      #merge {
        width: 100%;
        color: var(--color-primary);
        background-color: var(--color-light);
        margin-left: 0;
      }
    
      .button_volver {
        display: inline-block;
        padding: 10px 15px;
        margin-top: 10px;
        background-color: #007bff;
        color: white;
        text-decoration: none;
        border-radius: 5px;
      }
      .button_volver:hover {
        background-color: #0056b3;
      }
      .theory-section {
        margin-top: 30px;
        padding: 20px;
        border: 1px solid #ccc;
        border-radius: 10px;
        background-color: #f9f9f9;
      }
      .theory-section h2,
      .theory-section h3 {
        color: var(--color-primary);
      }
      .theory-section p,
      .theory-section ul {
        margin-left: 20px;
      }
      .theory-section code {
        display: block;
        background-color: #eaeaea;
        padding: 10px;
        border-radius: 5px;
        margin-top: 10px;
      }
    </style>
    <center><h1>Merge Sort</h1></center>
    <div id="div_info" class="infos">
      <div class="info__icon">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          viewBox="0 0 24 24"
          height="24"
          fill="none"
        >
          <path
            fill="#393a37"
            d="m12 1.5c-5.79844 0-10.5 4.70156-10.5 10.5 0 5.7984 4.70156 10.5 10.5 10.5 5.7984 0 10.5-4.7016 10.5-10.5 0-5.79844-4.7016-10.5-10.5-10.5zm.75 15.5625c0 .1031-.0844.1875-.1875.1875h-1.125c-.1031 0-.1875-.0844-.1875-.1875v-6.375c0-.1031.0844-.1875.1875-.1875h1.125c.1031 0 .1875.0844.1875.1875zm-.75-8.0625c-.2944-.00601-.5747-.12718-.7808-.3375-.206-.21032-.3215-.49305-.3215-.7875s.1155-.57718.3215-.7875c.2061-.21032.4864-.33149.7808-.3375.2944.00601.5747.12718.7808.3375.206.21032.3215.49305.3215.7875s-.1155.57718-.3215.7875c-.2061.21032-.4864.33149-.7808.3375z"
          ></path>
        </svg>
      </div>
      <div class="info__title">
        La teoría del Insert Sort es muy importante para usar este aplicativo
      </div>
      <div id="close_info" class="info__close">
        <svg
          height="20"
          viewBox="0 0 20 20"
          width="20"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="m15.8333 5.34166-1.175-1.175-4.6583 4.65834-4.65833-4.65834-1.175 1.175 4.65833 4.65834-4.65833 4.6583 1.175 1.175 4.65833-4.6583 4.6583 4.6583 1.175-1.175-4.6583-4.6583z"
            fill="#393a37"
          ></path>
        </svg>
      </div>
    </div>
    <a class="button_volver" href="merge"
      ><svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        style="width: 20px; height: 20px"
      >
        <path
          d="M8.83 6a30.23 30.23 0 0 0-5.62 5.406A.949.949 0 0 0 3 12m5.83 6a30.233 30.233 0 0 1-5.62-5.406A.949.949 0 0 1 3 12m0 0h18"
        ></path></svg
      >Volver</a
    >
    
    <div class="theory-section">
        <h2>Teoría del Merge Sort</h2>
        <p>
          Merge Sort es un algoritmo de ordenación de tipo divide y vencerás que 
          divide la lista en dos mitades, las ordena de manera recursiva y luego 
          combina las dos mitades ordenadas para formar la lista final ordenada.
        </p>
        <h3>Proceso del Merge Sort</h3>
        <ul>
          <li>Divide la lista en dos mitades iguales (o casi iguales).</li>
          <li>Ordena cada mitad recursivamente utilizando Merge Sort.</li>
          <li>Combina las dos mitades ordenadas para formar una lista ordenada.</li>
        </ul>
        <h3>Características del Merge Sort</h3>
        <ul>
          <li>Más eficiente que los algoritmos de ordenación simples como Bubble Sort e Insert Sort para listas grandes.</li>
          <li>Es un algoritmo estable, lo que significa que mantiene el orden relativo de los elementos con valores iguales.</li>
          <li>Requiere memoria adicional para la combinación de las sublistas.</li>
          <li>Funciona bien con listas enlazadas y estructuras de datos externas.</li>
        </ul>
        <h3>Complejidad del Merge Sort</h3>
        <ul>
          <li>Peor caso: O(n log n)</li>
          <li>Mejor caso: O(n log n)</li>
          <li>Promedio: O(n log n)</li>
        </ul>
        <h3>Algoritmo del Merge Sort</h3>
        <code>
          def merge_sort(arr):<br />
          &nbsp;&nbsp; if len(arr) > 1:<br />
          &nbsp;&nbsp;&nbsp;&nbsp; mid = len(arr) // 2<br />
          &nbsp;&nbsp;&nbsp;&nbsp; left_half = arr[:mid]<br />
          &nbsp;&nbsp;&nbsp;&nbsp; right_half = arr[mid:]<br />
          &nbsp;&nbsp;&nbsp;&nbsp; merge_sort(left_half)<br />
          &nbsp;&nbsp;&nbsp;&nbsp; merge_sort(right_half)<br />
          &nbsp;&nbsp;&nbsp;&nbsp; i = j = k = 0<br />
          &nbsp;&nbsp;&nbsp;&nbsp; while i < len(left_half) and j < len(right_half):<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if left_half[i] < right_half[j]:<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arr[k] = left_half[i]<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arr[k] = right_half[j]<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j += 1<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k += 1<br />
          &nbsp;&nbsp;&nbsp;&nbsp; while i < len(left_half):<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arr[k] = left_half[i]<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k += 1<br />
          &nbsp;&nbsp;&nbsp;&nbsp; while j < len(right_half):<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arr[k] = right_half[j]<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j += 1<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k += 1<br />
        </code>
      </div>
    
    <script>
      var close_info = document.getElementById("close_info");
      var div_info = document.getElementById("div_info");
    
      setTimeout(function () {
        div_info.style.display = "none";
      }, 5000);
    
      close_info.addEventListener("click", () => {
        div_info.style.display = "none";
      });
    </script>
    
    {% endblock %} {% block footer %}{{ super() }}{% endblock %}